// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  shortId        Int     @unique @default(autoincrement())
  name           String  @unique
  fullName       String
  password       String
  email          String  @unique
  birthDate      String
  dni            String  @unique
  phoneNumber    String
  gender         String
  instagram      String?
  mercadopago    String?
  googleDriveUrl String?
  role           Role
  code           String  @unique @default(dbgenerated("upper(substr(md5(random()::text), 1, 6))"))
  tags           Tag[]   @relation("USER_X_TAG")

  accounts      Account[]
  sessions      Session[]
  emailVerified DateTime? @db.Timestamptz
  image         String?

  scannedTickets       EmittedTicket[]    @relation("USER_X_EMITTED_TICKET")
  authorizedEvents     Event[]            @relation("EVENT_X_USER")
  eventsOrganized      EventXOrganizer[]  @relation("ORGANIZER_X_EVENT")
  ticketXOrganizer     TicketXOrganizer[] @relation("ORGANIZER_X_TICKET")
  ticketGroups         TicketGroup[]      @relation("ORGANIZER_X_TICKET_GROUP")
  ticketTypesOrganized TicketType[]       @relation("TICKET_TYPE_X_ORGANIZERS")
  // Optional for WebAuthn support
  Authenticator        Authenticator[]

  chiefOrganizerId String? @db.Uuid
  chiefOrganizer   User?   @relation("USER_X_CHIEF_ORGANIZER", fields: [chiefOrganizerId], references: [id], onDelete: SetNull)
  organizers       User[]  @relation("USER_X_CHIEF_ORGANIZER")

  createdAt DateTime @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamptz

  @@index([code])
  @@map("user")
}

model Tag {
  id   String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name String
  user User[] @relation("USER_X_TAG")

  @@map("tag")
}

model Account {
  userId            String  @db.Uuid
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  createdAt DateTime @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamptz

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
  @@map("account")
}

model Session {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  sessionToken String   @unique
  userId       String   @db.Uuid
  expires      DateTime @db.Timestamptz
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamptz

  @@map("session")
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime @db.Timestamptz

  @@id([identifier, token])
  @@map("verificationToken")
}

// Optional for WebAuthn support
model Authenticator {
  credentialID         String  @unique
  userId               String  @db.Uuid
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, credentialID])
  @@map("authenticator")
}

model Event {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name          String
  description   String
  coverImageUrl String
  slug          String
  startingDate  DateTime @db.Timestamptz
  endingDate    DateTime @db.Timestamptz
  minAge        Int?

  isDeleted Boolean @default(false)
  isActive  Boolean @default(false)

  locationId String    @db.Uuid
  location   Location? @relation("EVENT_X_LOCATION", fields: [locationId], references: [id])

  categoryId String        @db.Uuid
  category   EventCategory @relation("EVENT_X_CATEGORY", fields: [categoryId], references: [id])

  folderId String?      @db.Uuid
  folder   EventFolder? @relation("EVENT_FOLDER_X_EVENT", fields: [folderId], references: [id])

  authorizedUsers User[] @relation("EVENT_X_USER")

  // Los organizadores asociados al evento
  organizers      EventXOrganizer[] @relation("EVENT_X_ORGANIZER")
  inviteCondition InviteCondition   @default(TRADITIONAL)

  extraTicketData        Boolean @default(true)
  serviceFee             Float?
  emailNotification      String?
  ticketSlugVisibleInPdf Boolean @default(false)

  ticketTypes TicketType[] @relation("EVENT_X_TICKET_TYPE")

  ticketGroups TicketGroup[] @relation("EVENT_X_TICKET_GROUP")

  emittedTickets EmittedTicket[] @relation("EVENT_X_EMITTED_TICKET")

  ticketXOrganizers TicketXOrganizer[] @relation("EVENT_X_TICKET_X_ORGANIZER")

  createdAt DateTime @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamptz

  @@map("event")
}

model EventFolder {
  id     String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name   String
  color  String
  events Event[] @relation("EVENT_FOLDER_X_EVENT")

  createdAt DateTime @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamptz

  @@map("eventFolder")
}

model Location {
  id            String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name          String
  address       String
  googleMapsUrl String
  capacity      Int
  event         Event[] @relation("EVENT_X_LOCATION")

  createdAt DateTime @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamptz

  @@map("location")
}

model TicketType {
  id                String             @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name              String
  description       String
  price             Float?
  maxAvailable      Int
  maxPerPurchase    Int
  category          TicketTypeCategory
  maxSellDate       DateTime?          @db.Timestamptz
  visibleInWeb      Boolean            @default(true)
  lowStockThreshold Int?

  scanLimit DateTime? @db.Timestamptz

  organizers User[] @relation("TICKET_TYPE_X_ORGANIZERS")

  slug String @default(dbgenerated("upper(substr(md5(random()::text), 1, 6))"))

  event   Event  @relation("EVENT_X_TICKET_TYPE", fields: [eventId], references: [id], onDelete: Cascade)
  eventId String @db.Uuid

  tickets EmittedTicket[] @relation("TICKET_TYPE_X_EMITTED_TICKET")

  ticketTypePerGroup TicketTypePerGroup[] @relation("TICKET_TYPE_PER_GROUP_X_TICKET_TYPE")

  createdAt DateTime @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamptz

  @@unique([eventId, slug])
  @@map("ticketType")
}

model TicketGroup {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid

  status           TicketGroupStatus
  amountTickets    Int               @default(0)
  eventId          String            @map("event_id") @db.Uuid
  event            Event             @relation("EVENT_X_TICKET_GROUP", fields: [eventId], references: [id], onDelete: Cascade)
  invitedById      String?           @db.Uuid
  invitedBy        User?             @relation("ORGANIZER_X_TICKET_GROUP", fields: [invitedById], references: [id], onDelete: SetNull)
  isOrganizerGroup Boolean           @default(false)

  tickets            EmittedTicket[]      @relation("TICKET_X_TICKET_GROUP")
  ticketTypePerGroup TicketTypePerGroup[] @relation("TICKET_TYPE_PER_GROUP_X_TICKET_GROUP")
  ticketXOrganizers  TicketXOrganizer[]   @relation("TICKET_GROUP_X_ORGANIZER")

  createdAt DateTime @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamptz

  @@map("ticketGroup")
}

model TicketTypePerGroup {
  amount       Int
  ticketTypeId String     @db.Uuid
  type         TicketType @relation("TICKET_TYPE_PER_GROUP_X_TICKET_TYPE", fields: [ticketTypeId], references: [id])

  ticketGroupId String       @db.Uuid
  ticketGroup   TicketGroup? @relation("TICKET_TYPE_PER_GROUP_X_TICKET_GROUP", fields: [ticketGroupId], references: [id], onDelete: Cascade)

  @@id([ticketTypeId, ticketGroupId])
  @@map("ticketTypePerGroup")
}

model EmittedTicket {
  id             String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  fullName       String
  dni            String
  mail           String
  gender         String
  phoneNumber    String
  instagram      String?
  birthDate      String
  slug           String
  paidOnLocation Boolean @default(false)

  scanned   Boolean   @default(false)
  scannedAt DateTime? @db.Timestamptz

  scannedByUserId String? @db.Uuid
  scannedBy       User?   @relation("USER_X_EMITTED_TICKET", fields: [scannedByUserId], references: [id], onDelete: SetNull)

  ticketTypeId String     @db.Uuid
  type         TicketType @relation("TICKET_TYPE_X_EMITTED_TICKET", fields: [ticketTypeId], references: [id])

  ticketGroupId String       @db.Uuid
  ticketGroup   TicketGroup? @relation("TICKET_X_TICKET_GROUP", fields: [ticketGroupId], references: [id], onDelete: Cascade)

  // El organizador asociado al ticket (solo en modo invitacion)
  ticketXOrganizer TicketXOrganizer? @relation("TICKET_X_ORGANIZER")

  eventId String @db.Uuid
  event   Event? @relation("EVENT_X_EMITTED_TICKET", fields: [eventId], references: [id])

  createdAt DateTime @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamptz

  @@map("emittedTicket")
}

model EventCategory {
  id   String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name String

  events Event[] @relation("EVENT_X_CATEGORY")

  createdAt DateTime @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamptz

  @@map("eventCategory")
}

model Feature {
  id      String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  key     String  @unique
  enabled Boolean @default(false)
  value   String?

  createdAt DateTime @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamptz

  @@map("feature")
}

model TicketXOrganizer {
  ticketId String?        @db.Uuid
  ticket   EmittedTicket? @relation("TICKET_X_ORGANIZER", fields: [ticketId], references: [id], onDelete: Cascade)

  organizerId String @db.Uuid
  organizer   User   @relation("ORGANIZER_X_TICKET", fields: [organizerId], references: [id], onDelete: Cascade)

  ticketGroupId String?      @db.Uuid
  ticketGroup   TicketGroup? @relation("TICKET_GROUP_X_ORGANIZER", fields: [ticketGroupId], references: [id])

  eventId String @db.Uuid
  event   Event  @relation("EVENT_X_TICKET_X_ORGANIZER", fields: [eventId], references: [id])

  code String @unique @default(dbgenerated("upper(substr(md5(random()::text), 1, 6))"))

  createdAt DateTime @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamptz

  @@id([eventId, code])
  @@unique([ticketId])
  @@index([organizerId])
  @@index([code])
  @@map("ticketXOrganizer")
}

model EventXOrganizer {
  eventId String @db.Uuid
  event   Event  @relation("EVENT_X_ORGANIZER", fields: [eventId], references: [id])

  organizerId String @db.Uuid
  organizer   User   @relation("ORGANIZER_X_EVENT", fields: [organizerId], references: [id], onDelete: Cascade)

  discountPercentage Int?
  ticketAmount       Int?

  createdAt DateTime @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamptz

  @@id([eventId, organizerId])
  @@map("eventXOrganizer")
}

enum Role {
  ADMIN
  TICKETING
  ORGANIZER
  CHIEF_ORGANIZER
}

enum TicketGroupStatus {
  BOOKED
  PAID
  FREE
}

enum TicketTypeCategory {
  FREE
  PAID
  TABLE
}

enum InviteCondition {
  TRADITIONAL
  INVITATION
}
